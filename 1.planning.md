Goal

Multiplayer party-style game called Big Picture, where up to 8 players collaboratively evolve an image toward a hidden target goal image through a sequence of AI-drawn transformations, starting from a welcome screen with menu and room-based multiplayer.

First milestone: a welcome screen that can create/join a room and start a new 2–8 player game session with basic turn progression and placeholder images.
When to use

    New feature, service, or module.

    Non-trivial refactor or architecture change.

Steps
1. Clarify feature

    Welcome screen with:

        Game title (“Big Picture”), a “Start New Game” option, and “Join Game” by room code.

        Host creates a room; system shows a room code (e.g., 4–6 characters) on the main screen.

    Up to 8 players connect from personal devices (phone, tablet, laptop) using the room code and choose:

        Nickname.

        Avatar (simple set of avatars at first).

    Players can:

        Join and leave before the game is locked in.

        Rejoin (same nickname) if disconnected, as long as the game has not finished.

    Once everyone is in, any player on their device can press “All is in!” (only enabled when there are 2–8 players connected).

    Game then:

        Selects or generates a goal image: the target composition the group is trying to reach (for now can be a pre-defined image or AI-generated via an external model).

        Displays the goal image on the shared screen (and optionally on personal devices).

        Displays a starting image that is a simpler or partial version of the goal.

    Turn loop:

        The UI cycles through each player in turn, clearly showing current player nickname and avatar.

        On their device, the current player sees the current image plus four change options (e.g., “add X”, “change style to Y”, “move object Z”, “change color/theme”).

        Player picks one option; backend calls the image-generation service to produce a new image based on:

            Previous image.

            Chosen modification.

            Game state.

        Shared screen updates to show the new image.

    End condition:

        After a configured number of rounds (e.g., each player acts N times, or a total max number of steps), the game evaluates how close the final image is to the goal.

        Shows a “Success / Fail / Close Enough” result with some explanation or score (e.g., similarity score or qualitative categories).

    Future extensions (out of scope for first milestone but relevant for design):

        Optional hints, difficulty levels, scoring per player, persistent accounts, and different AI models for style vs. composition changes.

2. Define constraints

    Implementation language: Rust only.

    Game engine / runtime:

        Use Godot with Rust bindings (godot-rust via GDExtension or GDNative) as primary path for rendering and scene management.​

        Evaluate Jugar (https://crates.io/crates/jugar-web) only as a Rust-native support library or framework, but not for any JavaScript integration.

    Strict no JavaScript in client or server (no Node, no browser JS game loop).

    Target platforms:

        Main shared display: desktop (Windows/macOS/Linux) running the Godot game.

        Personal devices: thin clients (e.g., web or native), but actual protocol must be implementable without JS on your side (e.g., Godot exporting WebAssembly or using Rust-native desktop/mobile clients later).

    Networking:

        Use a Rust backend (e.g., axum, tokio) for lobby and game state if not embedded fully in Godot; all networking must be Rust-based.

    AI image generation:

        Pluggable external service (e.g., local model, remote API); accessed via Rust HTTP client.

        Model details are abstracted behind an internal image-generation interface.

    Complexity measurement:

        Use PMAT-style (https://crates.io/crates/pmat) thinking to estimate complexity and cyclomatc scoe per component or map to more standard metrics like cyclomatic and cognitive complexity for code-level review.​

        Track complexity per subsystem (lobby, turn engine, AI adapter, rendering) in a separate complexity.md.

3. Write acceptance criteria

Below is a concrete set of Given/When/Then scenarios for the first playable slice.

    Room creation and join

    Given the game is running on the main display,
    When the host selects “Start New Game” on the welcome screen,
    Then a new room is created with a unique code and the room code is visibly displayed on the main screen.

    Given a room code is displayed,
    When a player opens the join client and enters that room code plus a nickname,
    Then the player appears in the lobby player list on the main screen with their nickname and default avatar.

    Player limits

    Given fewer than 8 players are currently in the lobby,
    When another player attempts to join with a valid room code,
    Then they are allowed to join and are added to the lobby list.

    Given 8 players are already in the lobby,
    When a ninth player attempts to join with the same room code,
    Then the join is rejected with a clear “room full” message.

    Join / leave / rejoin

    Given a player is in the lobby,
    When they disconnect or press “Leave”,
    Then they are removed from the lobby list and the remaining players stay in the lobby.

    Given a player previously joined with nickname Alex and left before the game started,
    When they rejoin using the same room code and nickname Alex,
    Then they appear again as a player in the lobby without creating a duplicate entry.

    All is in / game start

    Given there are between 2 and 8 players in the lobby,
    When any player presses the “All is in!” button on their device,
    Then the game transitions from lobby to the game phase and no further players can join this room.

    Given the game has started from the lobby,
    When a player attempts to join using the same room code,
    Then the join is rejected with a message indicating the game is already in progress.

    Goal and starting images

    Given the game has just started from the lobby,
    When the game initializes the first round,
    Then a goal image and a starting image are selected/generated and both are available to the game logic.

    Given the goal and starting images exist,
    When the first player’s turn begins,
    Then the starting image (or current image) is shown on the shared screen, and the player’s device shows that image plus four distinct modification options.

    Turn progression and image update

    Given it is player N’s turn and they see four options,
    When they select one option and confirm,
    Then the system sends a request to the image-generation component and, on success, updates the shared image to the new version before moving to the next player.

    Given the current round is in progress and all players have taken exactly one turn,
    When the last player confirms their choice and the image is updated,
    Then the turn order wraps to the first player again (or to the next round according to the rules).

    End-of-game evaluation

    Given a configured limit of rounds or turns per player,
    When that limit is reached,
    Then the game computes a similarity/evaluation between the final image and the goal image (or uses a rule-based evaluation) and displays one of: “Success”, “Close”, or “Fail” on the main screen, along with a simple textual explanation.

    Given the game result has been displayed,
    When the host chooses “Return to Welcome Screen”,
    Then the room and game state are discarded, and the game returns to the initial welcome screen ready to start a new room.

4. Draft high-level design

Major components

    Client / Frontend

        Godot scene(s) for:

            Welcome screen (title, Start, Join).

            Lobby screen (room code, player list, “All is in!” state).

            Game screen (goal image, current image, turn indicator, result screen).

        Godot UI logic implemented in Rust via godot-rust:

            Handling button presses, input fields, transitions between scenes.

            Rendering textures for images (goal/current).

    Game Server / Session Manager (could be embedded or separate Rust service)

        Room management:

            Create room, validate room codes, track players and their states.

        Player management:

            Join, leave, rejoin, nickname/avatar assignment and validation.

        Game state machine:

            States: Lobby → Initializing → InRound → Evaluating → Finished.

            Turn ordering, round tracking, global game configuration (max players, round count).

        Image-state tracking:

            Current image, goal image, starting image, history of turns and chosen options.

    Image Generation Adapter

        Internal Rust trait, e.g.:

        rust
        pub struct ImageId(String);

        pub struct ImagePrompt {
            pub current_image: Option<ImageId>,
            pub goal_hint: Option<String>,
            pub modification_text: String,
        }

        pub trait ImageGenerator {
            fn generate(&self, prompt: ImagePrompt) -> Result<ImageId, ImageError>;
        }

        Concrete implementation that:

            Calls local or remote AI model via HTTP.

            Stores resulting images (disk, object storage, or in-memory for prototype).

    Evaluation Engine

        For initial version, a simple strategy:

            Use model-provided similarity score (if available), or

            Use a heuristic (e.g., number of required elements mentioned in the goal description that appear in the final prompt history), or

            Placeholder rule (e.g., always show “Close” until a real metric exists).

        Rust function, e.g.:

        rust
        pub enum GameOutcome {
            Success,
            Close,
            Fail,
        }

        pub fn evaluate_game(goal_description: &str, history: &[PlayerAction]) -> GameOutcome {
            // heuristic / placeholder
        }

Data flows

    Lobby creation flow

        Godot client (host) → Session Manager: POST /rooms → returns room_id, room_code.

        Godot main screen displays room_code.

    Player join flow

        Player device → Session Manager: POST /rooms/{room_code}/join with nickname/avatar → returns player_id and current lobby snapshot.

        Session Manager notifies main display client (via polling or WebSocket) to update lobby list.

    Game start flow

        Any player client → Session Manager: POST /rooms/{room_id}/start.

        Session Manager:

            Marks lobby closed.

            Requests goal and starting image from Image Generator.

        Session Manager → main display: “game started” event with initial images and first player.

    Turn flow

        Current player client requests four options from Session Manager (or options are precomputed per turn).

        Player chooses one option → Session Manager calls Image Generator with ImagePrompt.

        On success, Session Manager updates game state and notifies main display and all players with new current image and next player turn.

    End-of-game flow

        After last planned turn, Session Manager calls Evaluation Engine with goal description and action history.

        Session Manager sends result and explanation to clients.

Key interfaces (pseudo-code)

rust
pub struct Room {
    pub id: RoomId,
    pub code: String,
    pub players: Vec<Player>,
    pub state: RoomState,
    pub game: Option<GameState>,
}

pub enum RoomState {
    Lobby,
    InGame,
    Finished,
}

pub struct Player {
    pub id: PlayerId,
    pub nickname: String,
    pub avatar_id: AvatarId,
    pub connected: bool,
}

pub struct GameState {
    pub goal_image: ImageId,
    pub starting_image: ImageId,
    pub current_image: ImageId,
    pub players_in_order: Vec<PlayerId>,
    pub current_turn_index: usize,
    pub max_rounds: u32,
    pub actions: Vec<PlayerAction>,
}

pub struct PlayerAction {
    pub player_id: PlayerId,
    pub round: u32,
    pub option_chosen: OptionId,
    pub description: String,
    pub resulting_image: ImageId,
}

5. AI planning prompt

This is the “meta” prompt you feed to an AI to get a task breakdown and implementation plan, not code.

text
You are helping design a Rust-based multiplayer game called “Big Picture” using Godot + godot-rust and a Rust backend.

I will provide:
- The feature goal.
- Clarified behavior.
- Constraints.
- Acceptance criteria.
- High-level design and interfaces.

Your job:
- Produce an implementation plan ONLY.
- Break work into tasks and subtasks (1–3 developer-days each).
- Specify which files/modules to create or modify.
- Identify the hardest parts and open questions.
- Do NOT write any actual code.

Context:

see context.md 