# Project Context: Big Picture

## Current State
- **Domain**: Core game logic implemented in `crates/domain`. 71 tests passing.
- **Server**: Axum-based server in `crates/server`. Handles room creation, joining, and game state.
- **Client**: Godot-based client in `crates/client`. Implements Welcome Screen and Lobby Screen.
- **Deployment**: Configured for Fly.io using Docker.
- **Web Interface**: The server now serves a functional HTML landing page at the root URL for creating and joining rooms.

## Infrastructure
- **Language**: Rust (Nightly for deployment).
- **Frameworks**: Axum (Server), Godot-Rust (Client).
- **Deployment**: Fly.io (App: `big-picture-game`).

## Recent Changes
- Implemented `LobbyScreen` in Godot.
- Expanded domain tests to 71.
- Added HTML landing page to server for web-based room management.
- Updated client to point to `https://big-picture-game.fly.dev`.
- Configured Docker build with `Cargo.toml.docker` to isolate server/domain from client.

## Next Steps
- Verify Fly.io deployment (requires billing info).
- Test multi-device connectivity via the web interface and Godot client.
- Implement game start logic and turn progression.

        Track complexity per subsystem (lobby, turn engine, AI adapter, rendering) in a separate complexity.md.

3. Write acceptance criteria

Below is a concrete set of Given/When/Then scenarios for the first playable slice.

    Room creation and join

    Given the game is running on the main display,
    When the host selects “Start New Game” on the welcome screen,
    Then a new room is created with a unique code and the room code is visibly displayed on the main screen.

    Given a room code is displayed,
    When a player opens the join client and enters that room code plus a nickname,
    Then the player appears in the lobby player list on the main screen with their nickname and default avatar.

    Player limits

    Given fewer than 8 players are currently in the lobby,
    When another player attempts to join with a valid room code,
    Then they are allowed to join and are added to the lobby list.

    Given 8 players are already in the lobby,
    When a ninth player attempts to join with the same room code,
    Then the join is rejected with a clear “room full” message.

    Join / leave / rejoin

    Given a player is in the lobby,
    When they disconnect or press “Leave”,
    Then they are removed from the lobby list and the remaining players stay in the lobby.

    Given a player previously joined with nickname Alex and left before the game started,
    When they rejoin using the same room code and nickname Alex,
    Then they appear again as a player in the lobby without creating a duplicate entry.

    All is in / game start

    Given there are between 2 and 8 players in the lobby,
    When any player presses the “All is in!” button on their device,
    Then the game transitions from lobby to the game phase and no further players can join this room.

    Given the game has started from the lobby,
    When a player attempts to join using the same room code,
    Then the join is rejected with a message indicating the game is already in progress.

    Goal and starting images

    Given the game has just started from the lobby,
    When the game initializes the first round,
    Then a goal image and a starting image are selected/generated and both are available to the game logic.

    Given the goal and starting images exist,
    When the first player’s turn begins,
    Then the starting image (or current image) is shown on the shared screen, and the player’s device shows that image plus four distinct modification options.

    Turn progression and image update

    Given it is player N’s turn and they see four options,
    When they select one option and confirm,
    Then the system sends a request to the image-generation component and, on success, updates the shared image to the new version before moving to the next player.

    Given the current round is in progress and all players have taken exactly one turn,
    When the last player confirms their choice and the image is updated,
    Then the turn order wraps to the first player again (or to the next round according to the rules).

    End-of-game evaluation

    Given a configured limit of rounds or turns per player,
    When that limit is reached,
    Then the game computes a similarity/evaluation between the final image and the goal image (or uses a rule-based evaluation) and displays one of: “Success”, “Close”, or “Fail” on the main screen, along with a simple textual explanation.

    Given the game result has been displayed,
    When the host chooses “Return to Welcome Screen”,
    Then the room and game state are discarded, and the game returns to the initial welcome screen ready to start a new room.

4. Draft high-level design

Major components

    Client / Frontend

        Godot scene(s) for:

            Welcome screen (title, Start, Join).

            Lobby screen (room code, player list, “All is in!” state).

            Game screen (goal image, current image, turn indicator, result screen).

        Godot UI logic implemented in Rust via godot-rust:

            Handling button presses, input fields, transitions between scenes.

            Rendering textures for images (goal/current).

    Game Server / Session Manager (could be embedded or separate Rust service)

        Room management:

            Create room, validate room codes, track players and their states.

        Player management:

            Join, leave, rejoin, nickname/avatar assignment and validation.

        Game state machine:

            States: Lobby → Initializing → InRound → Evaluating → Finished.

            Turn ordering, round tracking, global game configuration (max players, round count).

        Image-state tracking:

            Current image, goal image, starting image, history of turns and chosen options.

    Image Generation Adapter

        Internal Rust trait, e.g.:

        rust
        pub struct ImageId(String);

        pub struct ImagePrompt {
            pub current_image: Option<ImageId>,
            pub goal_hint: Option<String>,
            pub modification_text: String,
        }

        pub trait ImageGenerator {
            fn generate(&self, prompt: ImagePrompt) -> Result<ImageId, ImageError>;
        }

        Concrete implementation that:

            Calls local or remote AI model via HTTP.

            Stores resulting images (disk, object storage, or in-memory for prototype).

    Evaluation Engine

        For initial version, a simple strategy:

            Use model-provided similarity score (if available), or

            Use a heuristic (e.g., number of required elements mentioned in the goal description that appear in the final prompt history), or

            Placeholder rule (e.g., always show “Close” until a real metric exists).

        Rust function, e.g.:

        rust
        pub enum GameOutcome {
            Success,
            Close,
            Fail,
        }

        pub fn evaluate_game(goal_description: &str, history: &[PlayerAction]) -> GameOutcome {
            // heuristic / placeholder
        }

Data flows

    Lobby creation flow

        Godot client (host) → Session Manager: POST /rooms → returns room_id, room_code.

        Godot main screen displays room_code.

    Player join flow

        Player device → Session Manager: POST /rooms/{room_code}/join with nickname/avatar → returns player_id and current lobby snapshot.

        Session Manager notifies main display client (via polling or WebSocket) to update lobby list.

    Game start flow

        Any player client → Session Manager: POST /rooms/{room_id}/start.

        Session Manager:

            Marks lobby closed.

            Requests goal and starting image from Image Generator.

        Session Manager → main display: “game started” event with initial images and first player.

    Turn flow

        Current player client requests four options from Session Manager (or options are precomputed per turn).

        Player chooses one option → Session Manager calls Image Generator with ImagePrompt.

        On success, Session Manager updates game state and notifies main display and all players with new current image and next player turn.

    End-of-game flow

        After last planned turn, Session Manager calls Evaluation Engine with goal description and action history.

        Session Manager sends result and explanation to clients.

Key interfaces (pseudo-code)

rust
pub struct Room {
    pub id: RoomId,
    pub code: String,
    pub players: Vec<Player>,
    pub state: RoomState,
    pub game: Option<GameState>,
}

pub enum RoomState {
    Lobby,
    InGame,
    Finished,
}

pub struct Player {
    pub id: PlayerId,
    pub nickname: String,
    pub avatar_id: AvatarId,
    pub connected: bool,
}

pub struct GameState {
    pub goal_image: ImageId,
    pub starting_image: ImageId,
    pub current_image: ImageId,
    pub players_in_order: Vec<PlayerId>,
    pub current_turn_index: usize,
    pub max_rounds: u32,
    pub actions: Vec<PlayerAction>,
}

pub struct PlayerAction {
    pub player_id: PlayerId,
    pub round: u32,
    pub option_chosen: OptionId,
    pub description: String,
    pub resulting_image: ImageId,

Now:
1. List the main subsystems to implement for this feature.
2. For each subsystem, list concrete tasks and suggested file/module names.
3. Call out integration points between Godot scenes and Rust code.
4. Call out integration points between the game server/session manager and image-generation backend.
5. Identify 5–10 key risks or open questions that should be resolved before coding.
