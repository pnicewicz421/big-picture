# Execution Protocol – Systematic Building with AI

This protocol defines how to turn the Big Picture specs into working Rust + Godot code in small, reviewable steps using AI as a pair programmer.

## Principles

- Small steps, small diffs.
- One concern per AI request.
- Human reviews every change.
- Specs and context are the source of truth (`spec/`, `CONTEXT.md`).

---

## Steps for a feature

### 1. Break into tasks

Start from `spec/<feature>.md` (for this project: `spec/big-picture.md`) and break the work into concrete development tasks of 1–3 dev-days each.

For **Big Picture**, typical task buckets are:

- **Core domain & types** [COMPLETED]
  - Define `Room`, `Player`, `GameState`, `PlayerAction`, and related enums/IDs.
  - Define configuration types (max players, round counts, etc.).
- **Session / room management** [COMPLETED]
  - Create room, generate room codes, track players and lobby state.
  - Handle join, leave, and rejoin semantics.
- **Game state machine** [IN PROGRESS]
  - Implement transitions: Lobby → InGame → Finished.
  - Implement turn order and round tracking.
- **Image generation adapter** [NOT STARTED]
  - Define `ImageId`, `ImagePrompt`, and `ImageGenerator` trait.
  - Implement one “stub” adapter for development, then a real AI-backed adapter.
- **Evaluation engine** [NOT STARTED]
  - Implement `GameOutcome` enum and a simple evaluation function.
- **Godot integration** [IN PROGRESS]
  - Implement Rust-backed scripts for:
    - Welcome screen scene. [COMPLETED]
    - Lobby screen scene. [COMPLETED]
    - Game screen (goal/current image, turn indicator, results). [NOT STARTED]
- **Networking / IPC (if separate backend)** [COMPLETED]
  - Define API endpoints or message formats for lobby, game start, turns, and results.

Write these tasks into `tasks/<feature>-tasks.md` (for example, `tasks/big-picture-lobby.md`) before asking AI for implementation help.

---

### 2. One-task prompts

For each task, work in a **single prompt** that focuses on that task only.

**General prompt pattern**

> “Implement only this task for Big Picture.  
> Task: \<paste from tasks file\>.  
> Allowed files to create/modify: \<list of files\>.  
> Follow all rules in CONTEXT.md and acceptance criteria in spec/big-picture.md.  
> Do not add new dependencies or change unrelated modules.  
> Respond with the exact Rust code edits only, no commentary.”

**Examples**

- *Domain types task*  
  - Task: “Define Room, Player, GameState, PlayerAction, and supporting enums/IDs for the Big Picture game backend, matching the spec.”  
  - Allowed files:
    - `src/domain/mod.rs`  
    - `src/domain/game.rs`

- *Lobby join flow task*  
  - Task: “Implement room creation and player join/leave logic, including capacity rules (2–8 players) and rejoin behavior as described in the spec.”  
  - Allowed files:
    - `src/domain/game.rs`  
    - `src/services/rooms.rs`  
    - `src/api/rooms.rs`

Keep the list of allowed files as tight as possible to catch drift.

---

### 3. Review & edit

After each AI-generated change:

1. **Read for spec alignment**
   - Check that behavior matches `spec/big-picture.md` acceptance criteria.
   - Check that constraints (Rust only, no JS, Godot + Rust binding usage) are respected.

2. **Check design and naming**
   - Ensure names match the domain language: `Room`, `GameState`, `PlayerAction`, etc.
   - Ensure types and functions fit your module layout in `CONTEXT.md`.

3. **Check correctness and safety**
   - Look for:
     - Panics that should be errors.
     - Unwrapped results that should be handled.
     - Lifetimes and ownership consistent with Rust idioms.
   - If something is unclear, ask the AI:
     - “Explain why you chose this data structure / pattern here.”

4. **Update docs**
   - If the change introduces or alters behavior:
     - Update the relevant section of `spec/big-picture.md` or `CONTEXT.md` as needed.
   - Optionally ask the AI:
     - “Generate a documentation snippet describing this module for inclusion in CONTEXT.md.”

Make edits manually as needed before committing.

---

### 4. Commit

For each completed and reviewed task:

- **Run tests/build**
  - Run `cargo build` and any available tests (`cargo test`, Godot test scenes, etc.).
- **Commit message format**
  - `feat(big-picture): <short description>` for new functionality.
  - `fix(big-picture): <short description>` for fixes.
  - `chore(big-picture): <short description>` for refactors or tooling.

Include a reference to the spec section and task file where possible, e.g.:

- `feat(big-picture): add Room and GameState types (#spec-rooms, tasks/big-picture-lobby.md)`  

Commit only after tests pass and the change is consistent with the spec and context.

---

### 5. Repeat

Continue task-by-task until:

- All acceptance criteria in `spec/big-picture.md` are satisfied for the current milestone (e.g., “welcome → lobby → basic game loop → simple evaluation”).  
- All relevant `tasks/*.md` items are either done, deferred (explicitly marked), or dropped with a reason noted.

For each new feature or milestone:

- Append new tasks to the appropriate `tasks/<feature>-tasks.md`.  
- If the architecture changes, update `CONTEXT.md` and, if needed, refine the Execution Protocol.

---

## Guardrails

- **Scope control**
  - Reject any AI suggestion that:
    - Touches files not listed in the prompt.
    - Introduces new services, dependencies, or patterns not grounded in `CONTEXT.md` or the spec.
- **Clarity**
  - If the AI introduces non-obvious logic, ask:
    - “Explain how this state machine works in terms of the Big Picture game phases.”
    - “Explain the invariants this code expects for Room and GameState.”
- **No silent architecture changes**
  - If a change implies a new responsibility (e.g., moving evaluation into a different module), pause and:
    - Update `CONTEXT.md` and `spec/big-picture.md` to reflect the new decision, or
    - Reject the change and ask for a version that fits the existing architecture.
- **Complexity awareness**
  - Periodically review modules against your complexity metric (PMAT / other) and:
    - Split or refactor modules whose complexity exceeds your thresholds.
    - Add notes to `complexity.md` when complexity grows.

By following this Execution Protocol, each Big Picture feature moves from spec to code in traceable, reversible increments that stay aligned with your architecture and constraints.
