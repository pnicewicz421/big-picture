//! Room management logic for handling multiple game sessions.

use std::collections::HashMap;
use rand::{distributions::Alphanumeric, Rng};
use crate::errors::RoomError;
use crate::player::Player;
use crate::room::{Room, RoomState};
use crate::types::{AvatarId, PlayerId, RoomId};

/// Manages active game rooms and player sessions.
#[derive(Debug, Default)]
pub struct RoomManager {
    /// Map of room codes to Room IDs.
    code_to_id: HashMap<String, RoomId>,
    
    /// Map of Room IDs to Room instances.
    rooms: HashMap<RoomId, Room>,
}

impl RoomManager {
    /// Create a new empty RoomManager.
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a new room with a unique random code.
    ///
    /// Returns the RoomId and the generated room code.
    pub fn create_room(&mut self) -> (RoomId, String) {
        let code = self.generate_unique_code();
        let room = Room::new(code.clone());
        let id = room.id;
        
        self.code_to_id.insert(code.clone(), id);
        self.rooms.insert(id, room);
        
        (id, code)
    }

    /// Join a room using a room code.
    ///
    /// Returns the RoomId and PlayerId if successful.
    pub fn join_room(
        &mut self,
        code: &str,
        nickname: String,
        avatar_id: AvatarId,
    ) -> Result<(RoomId, PlayerId), RoomError> {
        let room_id = self.code_to_id.get(code)
            .copied()
            .ok_or_else(|| RoomError::InvalidCode(code.to_string()))?;
            
        let room = self.rooms.get_mut(&room_id)
            .ok_or_else(|| RoomError::NotFound(code.to_string()))?;
            
        if room.state != RoomState::Lobby {
            return Err(RoomError::AlreadyStarted(room_id));
        }
        
        if room.is_full() {
            return Err(RoomError::Full(room_id));
        }
        
        if room.has_player_with_nickname(&nickname) {
            return Err(RoomError::NicknameTaken(nickname, room_id));
        }
        
        let player = Player::new(nickname, avatar_id);
        let player_id = player.id;
        room.add_player(player);
        
        Ok((room_id, player_id))
    }

    /// Rejoin a room if a player was disconnected.
    pub fn rejoin_room(
        &mut self,
        code: &str,
        nickname: &str,
    ) -> Result<(RoomId, PlayerId), RoomError> {
        let room_id = self.code_to_id.get(code)
            .copied()
            .ok_or_else(|| RoomError::InvalidCode(code.to_string()))?;
            
        let room = self.rooms.get_mut(&room_id)
            .ok_or_else(|| RoomError::NotFound(code.to_string()))?;
            
        let player = room.find_player_by_nickname(nickname)
            .ok_or_else(|| RoomError::NicknameTaken(nickname.to_string(), room_id))?; // Reusing error for "not found" in this context
            
        let player_id = player.id;
        
        // In a real app, we'd mark them as connected here
        if let Some(p) = room.find_player_mut(player_id) {
            p.reconnect();
        }
        
        Ok((room_id, player_id))
    }

    /// Leave a room.
    pub fn leave_room(&mut self, room_id: RoomId, player_id: PlayerId) -> Result<(), RoomError> {
        let room = self.rooms.get_mut(&room_id)
            .ok_or_else(|| RoomError::NotFound(room_id.to_string()))?;
            
        let is_host = room.players.first().map(|p| p.id == player_id).unwrap_or(false);

        if room.remove_player(player_id) {
            // If room is empty OR the host left, remove the room
            if room.player_count() == 0 || is_host {
                let code = room.code.clone();
                self.code_to_id.remove(&code);
                self.rooms.remove(&room_id);
            }
            Ok(())
        } else {
            Err(RoomError::PlayerNotFound(player_id, room_id))
        }
    }

    /// Start the game in a room.
    pub fn start_game(&mut self, room_id: &RoomId) -> Result<(), RoomError> {
        let room = self.rooms.get_mut(room_id)
            .ok_or_else(|| RoomError::NotFound(room_id.to_string()))?;
            
        if room.state != RoomState::Lobby {
            return Err(RoomError::AlreadyStarted(*room_id));
        }
        
        if !room.can_start() {
            return Err(RoomError::NotEnoughPlayers(*room_id));
        }
        
        // Create initial game state
        let player_ids: Vec<PlayerId> = room.players.iter().map(|p| p.id).collect();
        let (communal_goal, player_objects) = crate::assets::generate_game_assets(player_ids.len());
        
        let mut player_starting_objects = std::collections::HashMap::new();
        for (id, obj) in player_ids.iter().zip(player_objects) {
            player_starting_objects.insert(*id, obj);
        }

        // In a real game, these would be generated by an AI service
        let goal_image = crate::types::ImageId::new("goal_placeholder");
        let starting_image = crate::types::ImageId::new("start_placeholder");
        
        let game_state = crate::game::GameState::new(
            goal_image,
            communal_goal,
            starting_image,
            player_starting_objects,
            player_ids,
            3, // 3 rounds
        );
        
        room.start_game(game_state);
        
        Ok(())
    }

    /// Get a room by ID.
    pub fn get_room(&self, room_id: &RoomId) -> Option<&Room> {
        self.rooms.get(room_id)
    }

    /// Get a mutable reference to a room by ID.
    pub fn get_room_mut(&mut self, room_id: &RoomId) -> Option<&mut Room> {
        self.rooms.get_mut(room_id)
    }

    /// Get a room by code.
    pub fn get_room_by_code(&self, code: &str) -> Option<&Room> {
        self.code_to_id.get(code).and_then(|id| self.rooms.get(id))
    }

    /// Generate a unique 6-character alphanumeric room code.
    fn generate_unique_code(&self) -> String {
        let mut rng = rand::thread_rng();
        loop {
            let code: String = (0..6)
                .map(|_| rng.sample(Alphanumeric) as char)
                .map(|c| c.to_ascii_uppercase())
                .collect();
                
            if !self.code_to_id.contains_key(&code) {
                return code;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_room() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        assert_eq!(code.len(), 6);
        let room = manager.get_room(&id).unwrap();
        assert_eq!(room.code.len(), 6);
        assert_eq!(room.player_count(), 0);
    }

    #[test]
    fn test_join_room() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        let result = manager.join_room(&code, "Alice".to_string(), AvatarId::default());
        assert!(result.is_ok());
        
        let (room_id, player_id) = result.unwrap();
        assert_eq!(room_id, id);
        
        let room = manager.get_room(&id).unwrap();
        assert_eq!(room.player_count(), 1);
        assert!(room.find_player(player_id).is_some());
    }

    #[test]
    fn test_join_full_room() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        for i in 0..8 {
            manager.join_room(&code, format!("Player{}", i), AvatarId::default()).unwrap();
        }
        
        let result = manager.join_room(&code, "Ninth".to_string(), AvatarId::default());
        assert!(matches!(result, Err(RoomError::Full(_))));
    }

    #[test]
    fn test_duplicate_nickname() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        manager.join_room(&code, "Alice".to_string(), AvatarId::default()).unwrap();
        let result = manager.join_room(&code, "Alice".to_string(), AvatarId::default());
        assert!(matches!(result, Err(RoomError::NicknameTaken(_, _))));
    }

    #[test]
    fn test_leave_room() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        let (_, player_id) = manager.join_room(&code, "Alice".to_string(), AvatarId::default()).unwrap();
        assert_eq!(manager.get_room(&id).unwrap().player_count(), 1);
        
        manager.leave_room(id, player_id).unwrap();
        assert!(manager.get_room(&id).is_none(), "Room should be removed when empty");
    }

    #[test]
    fn test_invalid_room_code() {
        let mut manager = RoomManager::new();
        let result = manager.join_room("INVALID", "Alice".to_string(), AvatarId::default());
        assert!(matches!(result, Err(RoomError::InvalidCode(_))));
    }

    #[test]
    fn test_empty_room_code() {
        let mut manager = RoomManager::new();
        let result = manager.join_room("", "Alice".to_string(), AvatarId::default());
        assert!(matches!(result, Err(RoomError::InvalidCode(_))));
    }

    #[test]
    fn test_case_sensitive_room_code() {
        let mut manager = RoomManager::new();
        let (_id, code) = manager.create_room();
        
        // Try lowercase version of uppercase code
        let lowercase = code.to_lowercase();
        let result = manager.join_room(&lowercase, "Alice".to_string(), AvatarId::default());
        assert!(matches!(result, Err(RoomError::InvalidCode(_))));
    }

    #[test]
    fn test_rejoin_room() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        let (_, player_id) = manager.join_room(&code, "Alice".to_string(), AvatarId::default()).unwrap();
        
        // Leave and rejoin
        manager.leave_room(id, player_id).ok();
        let result = manager.join_room(&code, "Alice".to_string(), AvatarId::default());
        
        // After leaving, room is empty and deleted, so rejoin fails with InvalidCode
        assert!(matches!(result, Err(RoomError::InvalidCode(_))));
    }

    #[test]
    fn test_multiple_players_leave() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        let (_, p1) = manager.join_room(&code, "Alice".to_string(), AvatarId::default()).unwrap();
        let (_, p2) = manager.join_room(&code, "Bob".to_string(), AvatarId::default()).unwrap();
        let (_, p3) = manager.join_room(&code, "Charlie".to_string(), AvatarId::default()).unwrap();
        
        assert_eq!(manager.get_room(&id).unwrap().player_count(), 3);
        
        // Remove middle player
        manager.leave_room(id, p2).unwrap();
        assert_eq!(manager.get_room(&id).unwrap().player_count(), 2);
        
        // Remove first player (host) - room should be deleted
        manager.leave_room(id, p1).unwrap();
        assert!(manager.get_room(&id).is_none());
    }

    #[test]
    fn test_leave_nonexistent_room() {
        let mut manager = RoomManager::new();
        let fake_room_id = RoomId::new();
        let fake_player_id = PlayerId::new();
        
        let result = manager.leave_room(fake_room_id, fake_player_id);
        assert!(matches!(result, Err(RoomError::NotFound(_))));
    }

    #[test]
    fn test_leave_nonexistent_player() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        manager.join_room(&code, "Alice".to_string(), AvatarId::default()).unwrap();
        
        let fake_player_id = PlayerId::new();
        let result = manager.leave_room(id, fake_player_id);
        assert!(matches!(result, Err(RoomError::PlayerNotFound(..))));
    }

    #[test]
    fn test_room_code_uniqueness() {
        let mut manager = RoomManager::new();
        let mut codes = std::collections::HashSet::new();
        
        // Create 100 rooms and ensure all codes are unique
        for _ in 0..100 {
            let (_, code) = manager.create_room();
            assert!(codes.insert(code.clone()), "Code {} was not unique", code);
        }
        
        assert_eq!(codes.len(), 100);
    }

    #[test]
    fn test_room_code_format() {
        let mut manager = RoomManager::new();
        
        for _ in 0..50 {
            let (_, code) = manager.create_room();
            assert_eq!(code.len(), 6, "Code length must be 6");
            assert!(code.chars().all(|c| c.is_ascii_uppercase() || c.is_ascii_digit()), 
                   "Code must be alphanumeric uppercase: {}", code);
        }
    }

    #[test]
    fn test_get_mutable_room() {
        let mut manager = RoomManager::new();
        let (id, code) = manager.create_room();
        
        manager.join_room(&code, "Alice".to_string(), AvatarId::default()).unwrap();
        
        {
            let room = manager.get_room_mut(&id).unwrap();
            assert_eq!(room.player_count(), 1);
        }
        
        assert!(manager.get_room_mut(&id).is_some());
    }
}
